/**
 * ç»™å®šä¸€ä¸ªäºŒå‰æ ‘, æ‰¾åˆ°è¯¥æ ‘ä¸­ä¸¤ä¸ªæŒ‡å®šèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚
 * <p>
 * ç™¾åº¦ç™¾ç§‘ä¸­æœ€è¿‘å…¬å…±ç¥–å…ˆçš„å®šä¹‰ä¸ºï¼šâ€œå¯¹äºæœ‰æ ¹æ ‘ T çš„ä¸¤ä¸ªèŠ‚ç‚¹ pã€qï¼Œæœ€è¿‘å…¬å…±ç¥–å…ˆè¡¨ç¤ºä¸ºä¸€ä¸ªèŠ‚ç‚¹ xï¼Œæ»¡è¶³ x æ˜¯ pã€q çš„ç¥–å…ˆä¸” x çš„æ·±åº¦å°½å¯èƒ½å¤§ï¼ˆä¸€ä¸ª
 * èŠ‚ç‚¹ä¹Ÿå¯ä»¥æ˜¯å®ƒè‡ªå·±çš„ç¥–å…ˆï¼‰ã€‚â€
 * <p>
 * <p>
 * <p>
 * ç¤ºä¾‹ 1ï¼š
 * <p>
 * <p>
 * è¾“å…¥ï¼šroot = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
 * è¾“å‡ºï¼š3
 * è§£é‡Šï¼šèŠ‚ç‚¹ 5 å’ŒèŠ‚ç‚¹ 1 çš„æœ€è¿‘å…¬å…±ç¥–å…ˆæ˜¯èŠ‚ç‚¹ 3 ã€‚
 * <p>
 * <p>
 * ç¤ºä¾‹ 2ï¼š
 * <p>
 * <p>
 * è¾“å…¥ï¼šroot = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
 * è¾“å‡ºï¼š5
 * è§£é‡Šï¼šèŠ‚ç‚¹ 5 å’ŒèŠ‚ç‚¹ 4 çš„æœ€è¿‘å…¬å…±ç¥–å…ˆæ˜¯èŠ‚ç‚¹ 5 ã€‚å› ä¸ºæ ¹æ®å®šä¹‰æœ€è¿‘å…¬å…±ç¥–å…ˆèŠ‚ç‚¹å¯ä»¥ä¸ºèŠ‚ç‚¹æœ¬èº«ã€‚
 * <p>
 * <p>
 * ç¤ºä¾‹ 3ï¼š
 * <p>
 * <p>
 * è¾“å…¥ï¼šroot = [1,2], p = 1, q = 2
 * è¾“å‡ºï¼š1
 * <p>
 * <p>
 * <p>
 * <p>
 * æç¤ºï¼š
 * <p>
 * <p>
 * æ ‘ä¸­èŠ‚ç‚¹æ•°ç›®åœ¨èŒƒå›´ [2, 10âµ] å†…ã€‚
 * -10â¹ <= Node.val <= 10â¹
 * æ‰€æœ‰ Node.val äº’ä¸ç›¸åŒ ã€‚
 * p != q
 * p å’Œ q å‡å­˜åœ¨äºç»™å®šçš„äºŒå‰æ ‘ä¸­ã€‚
 * <p>
 * Related Topics æ ‘ æ·±åº¦ä¼˜å…ˆæœç´¢ äºŒå‰æ ‘ ğŸ‘ 1523 ğŸ‘ 0
 */

package leetcode.editor.cn;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * leetcode test.
 */
public class LowestCommonAncestorOfABinaryTree {

    /**
     * main method
     */
    public static void main(String[] args) {
        Solution solution = new LowestCommonAncestorOfABinaryTree().new Solution();
    }

    //leetcode submit region begin(Prohibit modification and deletion)

    /**
     * Definition for a binary tree node.
     * public class TreeNode {
     *     int val;
     *     TreeNode left;
     *     TreeNode right;
     *     TreeNode(int x) { val = x; }
     * }
     */
    class Solution {
        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
            Map<TreeNode, TreeNode> map = new HashMap<>();
            dfs(root, map);

            Set<TreeNode> pSet = new HashSet<>();

            TreeNode pA = p;
            while (pA != null) {
                pSet.add(pA);
                pA = map.get(pA);
            }

            TreeNode qA = q;
            while (qA != null) {
                if (pSet.contains(qA)) {
                    break;
                }

                qA = map.get(qA);
            }

            return qA;
        }

        public void dfs(TreeNode root, Map<TreeNode, TreeNode> map) {
            if (root.left != null) {
                map.put(root.left, root);
                dfs(root.left, map);
            }

            if (root.right != null) {
                map.put(root.right, root);
                dfs(root.right, map);
            }
        }
    }
//leetcode submit region end(Prohibit modification and deletion)

    public static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;

        TreeNode(int x) {
            val = x;
        }
    }

}